Java Memory Management
======================

How memory works
----------------

* Code optimistion
* Avoiding coding errors


В начале нужно понять термины _The Stack_ и _The Heap_.

Когда приложение выполняется, то ему нужен доступ к некоторому количеству памяти, чтобы хранить в нем создаваемые объекты. Эта память разделена на две секции - стэк и хип. 

Термин "стэк" широко используется. Но в действительности в Java приложении может быть не один, а множество стэков. У каждого thread есть собственный стэк. Стэк это очень эффективная структура данных, которая управляется JVM. Важным аспектом стэка является то, что Java знает точно, когда данные в стэке могут быть разрушены.

Стэк работает следующим образом - данные добавляются в верхнюю часть стэка. Каждый раз, когда добавляются новый блок данных, старые данные опускаются вниз стэка, в то время как новый блок данных поступает наверх. Данные могут быть добавлены в начало (верх) стека или взяты из начала стэка. При этом можно удалить только последний добавленный блок данных. Данные помещенные в стэк ранее не могу быть удалены пока на достигнут верха стэка. Эта структура данных известна также как First-in Last-out.

При каждом вызове функции Java помещает локальные переменные этой функции в стэк. Сначала в стэк помещаются аргументы функции, затем по мере иницаилазации локальных переменных они также добавляются в стэк. При вызове метода все переданные ему аргументы копируются и при входе в этот метод его скопированные аргументы добавляются в стэк. Таким образом переменные из вызывающего метода находятся внизу стэка и недоступны для текущего исполняемого метода. Затем, если в текущем методе появляются локальные переменные, то они также добавляются в стэк.

Когда происходит возврат из метода, все данные добавленные в стэк для этого метода удаляются из стэка. Это быстрая и эффективная операция. И таким образом при возврате в предыдущий метод стэк восстанавливается в то же состояние, в котором он был до вызова метода из которого произошел возврат.

При достижении конца метода main стэк опустошается. При достижении закрывающей скобки, все локальные переменные метода удалены из стэка и разрушены. Это происходит каждый раз при выходе из блока кода задающего область видимости.

Таким образом в Java все локальные переменные создаются в стэке и автоматически выкидываются из стэка, когда происходит выход из блока кода в котором они были определены. Это задает короткий срок жизни для локальных переменных.

Также следует помнить, что каждый Thread имеет свой собствнный стэк, и данные в стэке могут быть видны только в Потоке, который владеет этим стэком.


The role of the Heap
--------------------

Heap позволят хранить данные, которые имеют срок жизни более долгий, чем блок кода или функция, например данные, которые должны передаваться между разными методами. Хип может быть представлен как вся память приложения за исключением данных хранящихся в стэках. В приложении есть один Хип, который делится между всеми Потоками, и некоторое число стэков, по одному для каждого Потока. Все Потоки могут потенциально использовать Хип.

Важно:  
__В Java все объекты физически хранятся в heap__

Для объектов в хипе существуют локальные переменные указывающие на эти объекты и хранящиеся в стэке.
```Java
int age = 31;
String name = "Alice";
```
В данном случае локальная переменная age будет храниться в стэке. Тогда как String объект создается в хипе, а локальная переменная name указывающая на него хранится в стэке.

Объектные переменные являются лишь указателями на объекты в хипе, и сами как локальные переменные хранятся в стэке.
Переменные примитивного типа всегда хранятся в стэке.

При передаче в метод переменная всегда __передается по значению__, то есть метод всегда имеет дело с копией переданного ему аргумента.


Escaping References
-------------------

Понятие инкапсуляции подразумевает строгий контроль доступа к данным, хранящимся внутри класса. Обычные примитивные или immutable типы возвращаемые геттерами не могут быть изменены снаружи класса (кроме как с помощью сеттеров, если они есть).

Однако если геттер возвращает ссылку на коллекцию, то возникает проблема, так как вызывающий код получает коллекцию и может делать с ней все что угодно. То есть ссылка на коллекцю escaped из класса, в котором она должна была быть инкапсулирована. Это тоже самое, как если бы поле коллекции было объявлено public. То есть правила инкапсуляции были нарушены, из-за чего любой код в системе может менять содержимое коллекции. Это сделает возможный дебаггинг очень сложным.

