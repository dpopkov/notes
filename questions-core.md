[Index](README.md)

Вопросы
=======

Generics
--------

### Каковы ограничения generics?

1. Типы параметров не могут быть примитивного типа (не может быть `Pair<double>`).
2. Определение типа в рантайме возвращает только сырые (raw) типы. То есть с помощью `getClass()` нельзя определить, что объект принадлежит к определенному generic типу. Для всех дженериков отличающихся только параметрами типов `getClass()` вернет один и тот же класс.
3. Нельза создать массив параметризированных типов, например `Pair<String>[] table`. Но можно создать массив с wildcard типом и сделать cast, например `Pair<String>[] table = (Pair<String>[]) new Pair<?>[10]`. Однако это небезопасно, (см. Horstmann, v.1, 8.6.3).
4. Varargs предупреждения. При использовании методов вида `<T> void findFoo(T... elements)` виртуальная машина Java должна создать массив T[], что против правил. Однако в данном случае сделано послабление и будет сделано предупреждение, а не ошибка. Чтобы устранить предупреждение можно использовать аннотацию @SafeVarargs, это допустимо для методов, которые только читают элементы входного массива. (см. Horstmann, v.1, 8.6.4).
5. Нельзя создавать объекты типа new T(...) поскольку тип T заранее неизвестен и стирание типа превратит T в Object. Чтобы обойти это ограничение можно использовать передачу в метод конструктора для параметра типа. Например `Pair.makePair(String::new)`, где метод makePair получает `Supplier<T>`, используемый как конструктор для создания объектов типа T таким образом: `new Pair<>(constr.get(), constr.get())`. Также можно использовать Reflection и передавать в метод класс (тип `Class`) параметра типа, вызывая далее у него метод `newInstance()` (см. Horstmann, v.1, 8.6.5).
6. Нельзя создать generic массив вида `new T[2]`. Однако если массив используется только как внутреннее поле, то можно создать массив `Object` и делать cast. Если же массив создается методом и затем возвращается как результат, то следует использовать конструктор для массива в качестве одного из параметров метода с типом `IntFunction<T[]>`. Далее в методе этот конструктор может использоваться для создания массива: `constructor.apply(2);`.
Другим способом является использование Reflection: `T[] mm = (T[]) Array.newInstance(a.getClass().getComponentType(), 2);`.
 (см. Horstmann, v.1, 8.6.6).
7. Параметры типа не работают в статическом контексте generic классов. Если мы объявим параметр типа T для некоего класса Foo и попытаемся использовать этот тип T в объявлении статических полей или статических методов, то это не будет иметь никакого смысла, поскольку после стирания типов будет существовать только один класс Foo и одно статическое поле или метод.
8. Нельзя throw или catch экземпляры generic класса (см. Horstmann, v.1, 8.6.6).


### Где при вызове generic метода указывается аргумент типа?

Перед именем метода (в данном случае тип может быть опущен, так как он выводится из типа аргументов переданных в метод):
```java
String middle = ArrayArg.<String>getMiddle("Jack", "C.", "Sparrow");
```

### Как задать множественное ограничение для параметра типа generic-а?

Использовать `extends` и `&`: `<T extends BoundingType1 & BoundingType2>`


### Как создать generic array (T[])?

Если массив используется только как private instance field, то можно объявить массив как Object[] и использовать приведение типа при возвращении элементов. Например:

```java
public class ArrayList<E> {
    private Object[] elements;
    
    @SuppressWarnings("unchecked")
    public ArrayList() { elements = (E[]) new Object[10]; }
    
    @SuppressWarnings("unchecked") 
    public E get(int n) { return (E) elements[n]; }
    
    public void set(int n, E e) { elements[n] = e; } // no cast needed
}
```
Если же generic array возвращается методом, то нужно использовать либо ссылку на конструктор массива, либо рефлексию (см. Horstmann, v1, 8.6.6).
