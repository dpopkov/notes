Agile Разработка (Agile Software Development)
=============================================


Agile Design
------------

Понимание общей картины развивается вместе с проектом. С каждой итерацией, команда улучшает дизайн системы так, что он хорош настолько насколько он может быть хорош для системы в ее настоящем состоянии. Команда не тратит много времени на будущие требования и потребности. И также не пытается создать инфраструктуру для поддержки функциональнсоти, которая будет нужна завтра. Фокус делается на текущей структуре системы и на том, чтобы она была настолько хороша, насколько может.


Симптомы плохого дизайна
------------------------

1. Rigidity (Жесткость, Закрепощенность) - Дизайн трудно изменить, потому что каждое изменение заставляет делать другие изменения в других частях системы.
2. Fragility (Хрупкость, Неустойчивость) - Дизайн легко сломать, так как изменения приводят к поломкам в местах, которые не имеют концептуальной связи с изменяемой частью.
3. Immobility (Неподвижность) - Дизайн трудно использовать повторно, так как систему трудно распутать и выделить из нее компоненты, которые могут быть повторно использованы в других системах.
4. Viscosity (Вязкость)- Трудно сделать то что нужно правильным образом, так как сделать что-либо неправильно становится проще, чем сделать это правильно.
5. Needles Complexity (Излишняя Неоправданная Сложность) - Избыточный дизайн, присутствие инфраструктуры, не приносящей прямой выгоды.
6. Needles Repetition (Излишняя Неоправданная Повторяемость) - Система содержит повторяющиеся структуры, которые можно было бы объединить под единой абстракцией.
7. Opacity (Непрозрачность, Неясность, Неопределенность) - Дизайн трудно читать и понимать, он имеет плохую выразительность, плохо выражает свои намерения.

Эти симптомы похожи на code smells, но на более высоком уровне. Это smells, которые пропитывают общую структуру, а не небольшние участки кода.


Принципы, помогающие построить лучший дизайн
--------------------------------------------
1. SRP - The Single Responsibility Principle.
2. OCP - The Open-Close Principle.
3. LSP - The Liskov Substitution Principle.
4. DIP - The Dependency Inversion Principle.
5. ISP - The Interface Segregation Principle.

Design smell это симптом, который может быть измерен. Часто smell вызван нарушением одного или нескольких принципов. Например Rigitity часто является результатом недостаточного внимания принципу OCP.

Принципы применяются для удаления smells. Они не применяются если нет smells. Чрезмерное применение принципов может привести к design smell of Needles Compexity.


Design Smells
-------------


### Rigidity (Жесткость, Закрепощенность)

Закрепощенность  - это тенденция для системы быть трудноизменяемой, даже в простых случаях. Дизайн является закрепощенным если одно изменение вызывает каскад последующих изменений в зависимых модулях. Чем больше модулей должно быть изменено, тем более закрепощенный, жесткий дизайн.

Большинство разработчиков сталкиваются с этой ситуацией. Их просят сделать изменение, которое выглядит простым. Они делают разумное предположение о требуемом объеме работы. Но позднее они обнаруживают последствия изменений, которые они не предвидели. Они вынуждены модифицировать больше модулей, чем первоначально планировали. В итоге изменения отнимают больше времени, чем было запланировано. Когда их спрашивают "Почему?", они отвечают: "Это было намного сложнее, чем я думал!"


### Fragility (Хрупкость, Неустойчивость)

Хрупкость - это тенденции системы ломаться во многих местах после одного изменения. Часто новые проблемы обнаруживаются в местах, которые не имеют концептуальной связи с местом, где производится изменение. Починка этих проблем ведет к еще большему числу проблем, и команда разработчиков становится похожа на собаку преследующую собственный хвост.

Когда хрупкость модуля увеличивается, вероятность что изменение создаст неожиданные проблемы, приближается к уверенности. Такие модули встречаются нередко. Это модули, которые постоянно нуждаются в починке, они никогда не покидают списки багов, разработчики осведомлены о необходимости их редизайна (но никто не хочет это делать), эти модули становятся тем хуже, чем чаще вы их чините.


### Immobilty (Немобильность, Неподвижность)

Дизайн немобилен если он содержит части, которые могли бы быть полезны в других системах, но усилия и риск требуемые для отделения этих частей от исходной системы слишком велики. Это случается очень часто.


### Viscosity (Вязкость)

Вязкость может быть в двух формах: Вязкость Софта и Вязкость Окружения.

Когда разработчики сталкиваются с необходимостью внесения изменений, то они обычно располагают более чем одним способом сделать это. Некоторые способы сохраняют дизайн, некоторые нет (хаки). Если способы сохраняющие дизайн труднее применить, чем хаки, то Вязкость дизайна высока. Сделать неправильно проще, чем сделать правильно. Мы хотим чтобы изменения сохраняющие дизайн было легко делать.

Вязкость окружениея проявляется в медлительности и неэффективности. Например, если компиляция происходит очень долго, то разработчики вынуждены делать те изменения, которые не приводят к большой рекомпиляции, даже если эти изменения нарушают дизайн. Если система контроля версий требует часов чтобы внести в нее несколько файлов, тогда разработчики вынуждены делать такие изменения, которые будет легче закоммитить, несмотря на то, будет ли дизайн сохранен.

В обоих случаях, вязкий проект это проект, в котором дизайн софта трудно сохранить. Мы хотим создавать системы и проекты, в которых сохранять дизайн легко.


### Needles Complexity (Излишняя неоправданная сложность)

Дизайн содержит неоправданную сложность если в нем есть элементы, которые не являются на настоящее время полезными. Это часто происходит когда разработчики ожидают изменений в требованиях, и закладывают в софт механизмы для работы с потенциальными изменениями. На первый взгляд это кажется правильным. В конце концов, готовность к будущим изменениям должна сделать наш код более гибким и придупредить поздние тяжелые изменения.

К сожаленияю, эффект часто бывает обратным. Готовясь к слишком большому количеству непредвиденных обстоятельств, дизайн становится замусорен конструкциями, которые никогда не будут использованы. Некоторые из этих приготовлений будут полезны, но еще больше не будут. А тем временем дизайн несет на себе тяжесть всех этих неиспользуемых элементов. Это делает софт неоправданно сложным и трудным для понимания.


### Needles Repetition (Излишняя повторяемость)

Копипастинг может быть полезной операцией для редактирования текста, но он может быть катастрофичной операцией для редактирования кода. Слишком  часто программные системы построены на сотнях фрагментах повторяющегося кода. Это происходит так:

Когда есть нужна в коде, который делает нечто полезное, то разработчик смотрит в другие части кода, где он надеется найте готовое решение. Он вставляет найденный фрагмент в свой модуль и делает необходимые модификации.

Но найденный им код уже был кем-то также найден, скопипастен и отредактирован. И когда один и тот же код появляется снова и снова, в слегка различающихся формах, разработчики теряют абстракцию. Нахождение всех повторений и устранение их через использование надлежащей абстракции может не быть в их приоритетах, но это может сделать их систему легче в понимании и поддержке.

Когда в системе есть избыточный код, работа по изменению системы может стать трудной. Баги, найденные в таком повторяющемся коде, должны быть пофиксены в каждом повторении. Однако, поскольку каждое повторение слегка отличается от другого, то и фикс не всегда одинаков.


### Opacity (Непрозрачность, Неясность, Неопределенность)

Непрозрачность - это тенденция модуля быть трудным для понимания. Код може быть написан в чистой и выразительной манере, или он может быть написан в неясной и запутанной манере. Код, который развивается с течением времени, имеет тенденицю становиться более и более неясным с возрастом. Требуется постоянное усилие направленное на сохранение кода чистым и выразительным, чтобы минимизировать Непрозрачность.

Когда разработчики в начале пишут модуль, код видится им ясным. Это из-за того, что они погружены в него и понимают его на уровне первичной близости. Позже, когда эта близость стирается, они могут вернуться к этому модулю и удивиться, как было возможно написать нечто столь ужасное. Чтобы предотвратить это, разработчики должны помещать себя на место читателя и прилагать усилие для рефакторинга кода, с тем чтобы читатели лучше могли понимать его. Им также нужно, чтобы их код подвергался ревью со стороны других разработчиков.


SRP: The Single-Respoinsibility Principle (Принцип единственной ответственности)
--------------------------------------------------------------------------------

Принцип SRP был описан в работах Tom DeMarco и Meilir Page-Jones. Они назвали его cohesion (Сплоченность, Сцепление). Они определили cohesion как функциональную связанность элементов в модуле. В этой главе данное понятие будет немного изменено и cohesion будут считаться силы, заставляющие модуль или класс изменяться.

### SRP: The Single-Responsibility Principle

__A class should have only one reason to change.__

Почему важно разделять Ответственность по разным классам? Потому что каждая Ответственность это ось для изменений. Когда требования меняются, это изменение приводит к изменениям в Ответственности классов. Если класс несет более одной Ответственности, тогда у него более одной причины для изменений.

Если класс имеет более одной Ответственности, тогда Ответственности становятся связанными (спаренными). Изменения в оодной Ответственности могут отрицательно влиять или препятствовать способности класса выполнять другие Ответственности. Такой вид связанности ведет к Хрупкому дизайну, который ломается при изменениях неожиданным способом.

### Что такое Responsibility (Ответственность)?

В контексте SRP, мы определяем Ответственность как "причину для изменения".  Еслы вы можете подумать о более чем одном мотиве для изменения класса, значит этот класс имеет более одной Ответственности.

Однако, если приложение не изменяется таким способом, который заставляет различные Ответственности меняться в разное время, тогда здесь нет необходимости в их разделении. Иначе разделение вызовет Needles Complexity (Излишнюю Сложность).

Ось изменений является осью изменений только если изменения действительно происходят. Применять SRP, или любой другой принцип, нет необходимости, если нет симптома.


