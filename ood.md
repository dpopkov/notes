ООД
===

* [1 - Что такое SOLID?](#q01)
* [1.1 - Каковы признаки плохого кода?](#q01.1)
* [2 - Для чего используется JavaDoc?](#q02)
* [3 - Как писать JavaDoc?](#q03)
* [4 - Что такое Java code conventions?](#q04)
* [5 - Расскажите про принципы составления Java класса](#q05)
* [6 - Что такое SRP?](#q06)
* [6.1 - Что такое Cohesion?](#q0601)
* [6.2 - Что такое Responsibility (Ответственность)?](#q0602)
* [7 - Расскажите о нарушениях принципа SRP.](#q07)
* [8 - Последствия нарушения SRP.](#q08)
* [8.1 - Решения SRP.](#q0801)
* [9 - Что такое OCP?](#q09)
* [10 - Расскажите о нарушениях принципа OCP](#q10)
* [11 - Последствия нарушения OCP](#q11)
* [12 - Что такое LSP?](#q12)
* [13 - Расскажите о нарушениях принципа LSP](#q13)
* [14 - Последствия нарушения LSP](#q14)
* [15 - Что такое ISP?](#q15)
* [16 - Расскажите о нарушения принципа ISP](#q16)
* [17 - Последствия нарушения ISP](#q17)
* [18 - Что такое DIP?](#q18)
* [19 - Расскажите о нарушениях принципа DIP](#q19)
* [20 - Последствия нарушения DIP](#q20)


1 - Что такое SOLID?<a name="q01"></a>
--------------------------------------
SOLID - это акроним представляющий 5 принципов дизайна классов в объектно-ориентированном проектировании.  
S - Single Responsibility Principle,  
O - Open Closed Principle,  
L - Liskov Substitution Principle,  
I - Interface Segregation Principle,  
D - Dependency Inversion Principle.  
Эти принципы были собраны и организованы Робертом Мартином в книге "Agile Software Development. Principles, Patterns, and Practices". 
Применение этих принципов делает код более расширяемым и адаптивным к возможным изменениям, более логичным и читабельным, а также пригодным к повторному использованию.

### acdpsp
SOLID - это акроним для набора практик, которые при совместном использовании делают код адаптивным к изменениям. 


1.1 - Каковы признаки плохого кода?<a name="q01.1"></a>
--------------------------------------
__Закрепощенность (Rigidity)__ - система с трудом поддается изменениям, так как самое минимальное изменение вызывает эффект снежного кома и заставляет делать изменения в других частях системы.

__Хрупкость, Неустойчивость (Fragility)__ - в результате изменений система ломается в других местах, которые не имеют прямого отношения к изменяемому компоненту.

__Неподвижность (Immobility)__ - трудно распутать систему и выделить из нее компоненты, которые могли бы повторно использоваться в других системах.

__Вязкость (Viscosity)__ - Сделать что-либо правильно намного сложнее, чем выполнить некорректные действия.

__Неоправданная сложность__ - Проект содержит инфраструктуру не приносящую непосредственной выгоды.

__Повторяемость__ - Проект содержит повторяющиеся структуры, которые можно было бы объединить под единой абстракцией.

__Неопределенность__ - Исходный код трудно читать и понимать.


2 - Для чего используется JavaDoc?<a name="q02"></a>
----------------------------------

Для описания классов, интерфейсов, полей, конструкторов, методов и пакетов с возможностью автоматического создания документации. Джавадок описывает ответственность класса. Если при описании происходит перечисление, то это может быть признаком нарушения SRP.


3 - Как писать JavaDoc?<a name="q03"></a>
-----------------------

Javadoc помещается перед документируемым элементом и заключается в символы слэш-звездочка-звездочка и закрывающая звездочка-слэш , в начале следует общее описание класса или метода, затем могут использоваться автономные дескрипторы начинающиеся с символа @ и помещаемые в начале строки, которые применяются для документации автора, версии, параметров и возвращаемого значения метода, описания выбрасываемых исключений и ссылок. Используются также встроеенные дескрипторы в фигурных скобках, например {@link reference}. 


6 - Что такое SRP?<a name="q06"></a>
------------------------------------
SRP - Single Responsibiltiy Principle.  
Each class in your system should have only one responsibility.  
Alternative definition: You should be able to describe what each class does withou saying "and".  
Better definition: Each class should have only one reason to change.  
Class follows SRP if you can't come up with more than one reason for a class to change.
Responsibility == reason to change.  

SRP violations lead to excessive coupling.

#### acdpsp

Принцип SRP рекомендует писать код, который имеет одну и только одну причину для изменений. Если у класса более одной причины меняться, это значит у него более одной ответственности. Классы с более чем одной ответственностью должны быть разбиты на меньшие классы, каждый из которых должен иметь только одну ответственность и причину для изменения.

Через процесс делегирования и абстракции класс имеющий слишком много причин для изменений должен делегировать одну или несколько ответственностей другим классам.

#### asdppp

Первоначально этот принцип соотносился с понятием Cohesion (Связность,Сплоченность) - функциональная взаимосвязь элементов модуля сфокусированных на одной главной цели. 
Позже (Боб Мартин) смысл сместился в сторону сил, которые вызывают изменения в модуле или классе.

__A class should have only one reason to change.__

Важно разделить ответственности на отдельные классы, потому что каждая ответственность является направлением для возможного изменения. Когда требования меняются, это изменение проявится через ответственности, которые несет на себе класс. Если класс имеет более одной ответственности, то у него будет более одной причины для изменения. В этом случае ответственности могут вступить в зацепление или сопряжение друг с другом и изменения в одной ответственности могут нарушить способность класса исполнять другие ответственности. Такой тип зацепления ведет к хрупкому дизайну который при модификации может ломаться в неожиданных местах.

#### clarch

SRP является следствием закона Конвея: лучшей является такая структура программной системы, которая формируется в основном под влиянием социальной структуры организации, использующей эту систему, поэтому каждый программный модуль имеет одну и только одну причину для изменения.

Исторически SRP формилировался так:
A module should have one, and only one, reason to change.  
Модуль должен иметь одну и только одну причину для изменения.

Програмные системы изменяются для удовлетворения потребностей пользователей и заинтересованных лиц, которые и являются причиной для измененний. В действительности здесь имеется в виду группа из одного или более человек, которые нуждаются в конкретном изменении. Тогда более полное определение будет таким:  
A module should be responsible to one, and only one, actor.  
Модуль должен нести ответственность перед одним и только одним актором или абстрактной ролью пользователя.  
Это может быть сформулировано также как: 
Класс должен иметь только одну ответственность, то есть изменения только одной части спецификации должны вызывать изменения в классе.

#### A

SRP - Принцип Единственной Ответственности утверждает, что каждый модуль или класс должен нести ответственность за одну конкретную часть функциональности предоставляемой программой и эта ответственность должна быть полностью инкапсулирована этим модулем или классом. 
Первоначально этот принцип соотносился с понятием Cohesion (Связность, Сплоченность) - это связность элементов модуля сфокусированных на одной главной цели.
Позже Боб Мартин сместил смысл в сторону сил, которые вызывают изменения в модуле или классе. "Класс должен иметь только одну причину для изменения".
Чем больше класс имеет ответственностей, тем больше у него причин для изменения. В этом случае ответственности могут вступать в зацепление или сопряжение (Coupling) друг с другом и изменения в одной ответственности (например изменения в требованиях) могут нарушить способность класса исполнять другие ответственности. Такой тип зацепления ведет к хрупкому дизайну который при модификации может ломаться в неожиданных местах.


6.1 - Что такое Cohesion?<a name="q0601"></a>
-------------------------

Cohesion - связность или прочность - это то, насколько хорошо все методы класса или все фрагменты метода соответствуют главной цели, - иначе говоря, насколько сфокусирован класс на той задаче, которую он решает.


6.2 - Что такое Responsibility (Ответственность)?<a name="q0602"></a>
-------------------------------

Responsibility (Ответственность) - это причина для изменения. Если можно представить более одного мотива для изменения класса, это значит класс имеет более одной ответственности.


7 - Расскажите о нарушениях принципа SRP.<a name="q07"></a>
-----------------------------------------

Если у класса более чем одна ответственность, то между этими ответственностями может произойти зацепление (Coupling) и тогда изменения в одной ответственности могут нарушить способность класса обслуживать другие ответственности.
Например класс Employee содержит три метода: calculatePay(), reportHours(), и save(). Здесь нарушается SRP, так как эти 3 метода ответственны перед бухгалтерией, отделом персонала, и администратором БД. В таком классе объединен код обслуживающий разных акторов. В результате изменения инициированные одним актором, могут затронуть и негативно повлиять на код, обслуживающий других акторов.


8 - Последствия нарушения SRP.<a name="q08"></a>
------------------------------

1-е последствие - возможность случайного дублирования.
В примере с Employee методы calculatePay() и reportHours() могут использовать общий алгоритм расчета не сверхурочных часов, который, чтобы избежать дублирования кода, был помещен в метод regularHours(). Если бухгалтерия решит изменить алгоритм расчета часов, то разработчик внесет требуемые изменения, несмотря на то, что другой актор - отдел кадров не в курсе этого изменения. Ими будет использоваться система выдающая новый результат без их ведома и это может быть обнаружено не сразу, что приведет к неприятным последствиям.  
То есть в данном случае произошло зацепление (Coupling) между двумя ответственностями класса, которое привело к хрупкости (Fragility), то есть изменения в одном месте системы привело к поломке в другом неожиданном месте.

2-е последствие - это риск при слиянии изменений. Например администратор БД вносит изменение в схему таблицы, а сотрудники отдела персонала хотят изменить формат отчета reportHours(). Два разных разработчика вносят независимо друг от друга изменения в одном классе, что потом приводит к необходимости разрешения коллизий при слиянии. Это подвергает риску оба изменения, так как при объемных изменениях провести слияние сложно и есть вероятность ошибки.


8.1 - Решения SRP.<a name="q0801"></a>
------------------

Наиболее очевидным способом решить проблему является отделение данных от функций и выделение данных в самостоятельный класс, а также создание отдельных классов для обслуживания разных ответственностей. Например PayCalculator, HourReporter, EmployeeSaver. Так как кол-во классов увеличится, то можно применить шаблон Фасад и делегировать эти ответственности соответствующим объектам.

Для реализации SRP также используется шаблон Декоратор.

9 - Что такое OCP?<a name="q09"></a>
-------------------

#### asdppp

OCP: The Open-Closed Principle - Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
То есть система должна легко подвергаться расширению путем добавления нового кода, а не изменения существующего кода.
Если одно изменение в программе приводит к каскаду изменений в зависимых местах, это признак Жесткости (Закрепощенность, Rigidity). В этом случае следует произвести рефакторинг, с тем чтобы дальнейшие изменения такого типа не приводили к большим модификациям. Если OCP применен правильно, то дальнейшее расширение достигается за счет добавления нового кода, а не изменения существующего кода.

Решением является введение абстракции способной защитить от возможных последующих изменений, когда код в классе закрытом для модификации, использует вызовы методов интерфейса или абстрактного класса, потомки которого могут добавлять и расширять функциональность.
При этом OCP не может быть применен против всех возможнох изменений, а только против наиболее вероятных, так как лишние абстракции увеличивают сложность дизайна программы.


10 - Расскажите о нарушениях принципа OCP<a name="q10"></a>
-----------------------------------------

#### asdppp

Примером нарушения OCP может быть программа отрисовки геометрических фигур, которая в цикле перебирает фигуры и в зависимости от типа фигуры вызывает ту или иную функцию отрисовки. Если будут добавлены новые типы фигур, то в этот код должны быть внесены изменения учитывающие новые типа, то есть он не является закрытым для модификации.


11 - Последствия нарушения OCP<a name="q11"></a>
------------------------------

#### asdppp

В примере с отрисовкой фигур, где цикл отрисовки в зависимости от типа фугуры вызывет ту или иную функцию отрисовки, при добавлении нового типа фигуры изменениями будет затронуто не только отрисовка фигур, но код в любом классе или методе, исполнение которого зависит от типа фигуры. Поиск всех мест, где необходимо будет внести изменения может быть затруднительным. То есть незакрытый от модификации класс делает структуру программы Жесткой (Закрепощенной), а также Хрупкой (Неустойчивой), так как можно пропустить некоторые места, где необходимо добавить обработку новых типов фигур.
Решением будет создать абстрактный метод отвечающий за отрисовку фигуры, тогда каждый класс нового типа геометрической фигуры может быть добавлен в программу и при этом, благодаря полиморфизму, не потребуется менять код вызывающий метод отрисовки. В таком случае не будет необходимости также искать места нуждающиеся в обновлении из-за добавления нового типа, следовательно такой код не будет Хрупким (Неустойчивым).


12 - Что такое LSP?<a name="q12"></a>
--------------------

#### asdppp

__Subtypes must be substitutable for their base types.__  
__Базовые типы должны заменяемы подтипами.__

При наследовании поведение подтипа не должно противоречить поведению базового типа. Мы можем использовать взаимозаменяемые части, но для этого они должны придерживаться некоторого договора или контракта. В случае наследования подклассы обязаны соблюдать контракт базового класса.
Также LSP делает возможным OCP, так как заменяемость типов дает возможность расширения без модификации базового типа.

#### acdpsp

Соблюдение LSP делает возможным иерархии типов, в которых пользователь базового класса может использовать объекты его подклассов без опасения что ожидаемое поведение будет нарушено.

Если LSP не соблюдается, то расширение иерархии может потребовать изменений в коде использующем базовый класс или интерфейс. При соблюдении LSP клиенты могут не знать об изменениях в иерархии. Пока не изменений в самом интерфейсе, до тех пор нет необходимости изменять существующий клиентский код. Таким образом LSP помогает соблюдению OCP и SRP.

__Если Б является подклассом А, то объекты типа А могут быть заменены объектами типа Б без нарушения работы программы.__



13 - Расскажите о нарушениях принципа LSP<a name="q13"></a>
-----------------------------------------

#### asdppp

Предположим что есть метод принимающий в качестве параметра некий базовый класс A. Также существует его подтип B, который при передаче его в этот метод приводит к неправильному поведению метода. В данном случае подкласс B нарушает принцип LSP. Если программист будет в этом методе проверять, не является ли переданный аргумент объектом класса B, то это нарушит принцип OCP, так как метод не будет закрыт для модификации для всех последующих подклассов класса A. Такие проверки являются неправильной реакцией на нарушение LSP.

Пример 1.
Классы Circle и Square наследуют от базового класса Shape. В обоих под-классах есть метод draw(), но его нет в базовом классе. Тогда метод занимающийся отрисовкой массива Shape вынужден проверять тип Shape и делать приведение типа для вызова метода draw(), что является нарушением OCP. То что подклассы не могут быть подставлены на место базового класса является нарушением LSP, что далее приводит к нарушению OCP.

Пример 2.
Класс Square наследует от класса Rectanlge. Для класса Square сеттеры длины и ширины устанавливают одинаковые значения для обоих полей. Предположим что есть метод принимающий Rectangle, меняющий его длину и ширину, затем делающий вычисления основанные на значениях переданных в сеттеры. Если реальным объектом будет Square, то вычисления могут быть неверными, так как поведение Square касающееся его длины и ширины отличается от поведения Rectangle. Это является нарушением LSP.


14 - Последствия нарушения LSP<a name="q14"></a>
------------------------------

Однимм из последствий являются ошибки в методах принимающих базовый класс и ожидающих от него соответствующего поведения, так как программист пишущий такой методв в праве делать разумные предположения о поведении базового класса. Однако если подкласс ведет себя иначе, нарушая контаркты базового класса, то это может вызвать ошибки в таком методе. В контексте такого метода код нарушающего LSP подкласса является Fragile (Хрупким).

Также нарушение LSP может вести к нарушению OCP (пример с Shape). Например если метод принимает в качестве параметра базовый класс, то в нем для защиты от ошибок может делаться проверка реального типа переданного объекта подкласса, чтобы обеспечить его правильное использование. Но такая проверка нарушает OCP потому что данный код обязан знать обо всех подклассах, следовательно он не закрыт для модификации при возможных добавлениях подклассов.


14.1 - Признаки возможного нарушения LSP
----------------------------------------

### Дегенерация функций в производных типах

Если в базовом классе есть метод содержащий код, а в подклассе этот метод переопределен, но имеет пустое тело без кода, так как автор подкласса решил, что данный метод бесполезен для его класса. Однако пользователи базового класса не знают об этом. Здесь может быть нарушение подставляемости и, следовательно, нарушение LSP.

### Выбрасывание исключений в производных типах

Другой формой нарушения является добавления исключений в методы производного класса, при том что в базовом классе эти методы не выбрасывают исключений. Если пользователи базового класса не ожидают исключений, тогда добавление их в производный класс делает его неподставляемым.


15 - Что такое ISP?<a name="q15"></a>
-------------------

#### asdppp

Этот принцип служит для защиты от "толстых" интерфейсов. Классы с "толстыми" интерфейсами имеют низкую связность (Cohesion). Другими словами, такой интерфейс может быть разбит на группы интерфейсов, каждая из которых обслуживает свою группу клиентов. Одни клиенты используют одну группу методов, а другие - другую группу методов. Некоторые объекты могут иметь Несвязный интерфейс, но клиентский код не должен знать о них как об одном классе. Вместо этого клиентский код должен знать об отдельных Связных интерфейсах.

__Clients should not be forced to depend on methods that they do not use.__

Когда клиенты вынуждены зависеть от методов, которые они не используют, то они все равно зависят от изменений в этих методах. Это приводит к ненамеренному зацеплению между всеми клиентами. Другими словами, когда клиент зависит от класса содержащего методы не используемые клиентом, но используемые другими клиентами, тогда это клиент будет испытывать влияние от изменений в интерфейсе, к которым вынудят эти другие клиенты. Такого зацепления следует избегать где только возможно и производить разделение интерфейсов.


ISP - следует избегать заависимостей от того, что не используется


16 - Расскажите о нарушения принципа ISP<a name="q16"></a>
---------------------------------------- 

Если имплементация интерфейса добавляется в абстрактный класс, при том, что не все, а только некоторые потомки абстрактного класса нуждаются в нем, это приведет к тому что некоторые потомки будут иметь пустые методы данного интерфейса, то есть дегенерированную имплементацию, что уже есть потенциальное нарушение LSP. Это пример загрязнения интерфейса, когда интерфейс класса загрязняется методами в которых он не нуждается, только ради некоторых его потомков.


17 - Последствия нарушения ISP<a name="q17"></a>
------------------------------

Если класс используется разными типами клиентов, то и интерфейсы для них должны быть разделены. Потому что клиенты могут влиять на те интерфейсы, которые они используют. Если потребности клиентского кода меняются, то это приводит к необходимости изменений во все классах имплементирующих интерфейс, включая те, которые имплементируют его лишь формально и имеют пустые методы. Это является признаком Rigidity (Закрепощенность) и Viscocity (Вязкость). Когда изменения в одной части программы влияет на части концептуально с ней не связанные, то стоимость таких изменений становится непредсказуемой и возрастает риск негативных последствий.


18 - Что такое DIP?<a name="q18"></a> 
------------------- 

__a. High-level modules should not depend on low-level modules. Both should depend on abstractions.__  
__b. Abstractions should not depend on details. Details should depend on abstractions.__  

Традиционное процедурное программирование создает структуру зависимостей при которой код верхнего уровня зависит от нижнего. Это делает код верхнего уровня зависимым от изменений в нижнем. DIP переворачивает эту структуру зависимостей таким образом, чтобы оба зависели от абстракции, при этом верхний уровень часто владеет теми интерфейсами, которые он использует.
Если DIP применен, то программа имеет ОО дизайн, если нет, то процедурный. Применение DIP необходимо для создания кода устойчивого к изменениям, а также необходимо для создания фреймворков.


19 - Расскажите о нарушениях принципа DIP<a name="q19"></a>
-----------------------------------------

Пример управления лампы с помощь кнопки. Есть класс Button, который имеет поле типа Lamp и вызывает его методы turnOn(), turnOff(). Класс Button напрямую зависит от класса Lamp, то есть изменения в Lamp повлиявют на Button. Кроме того, невозможно изпользовать Button для управления объектами других типов. Он может управлять только Lamp. Это нарушает DIP. Верхний уровень не отделен от нижнего уровня. Абстракция не отделена от деталей. Без этого разделения правила верхнего уровня автоматически зависят от нижнего уровня и абстракция автоматически зависит от деталей.
Абстракция верхнего уровня по сути не должна меняеться если детали ее реализации изменились. Это система внутри системы. В примере с кнопкой это определение состояния нажата-ненажата и передача этого состояния в целевой объект. При этом механизм целевого объекта не важен. Это детали, которые не должны влиять на абстракцию.

Решение состоит в введении промежуточной абстракции - интерфейса, который используется верхним уровнем и имплементируется классом нижнего уровня. Это дает возможность верхнему уровню использовать разные целевые объектв,в том числе еще не существующие типы.


20 - Последствия нарушения DIP<a name="q20"></a>
------------------------------

При нарушении DIP модули и классы верхнего уровня будут испытывать влияние от изменения в нижнем уровне. Кроме того их нельзя будет использовать повторно с другим нижним уровнем.


DIP - модули верхних уровней не должны зависет от модулей нижних уровней, оба должны зависеть от абстракций 


Legend
------

acdpsp - Agile coding with Design Patterns and SOLID Principles  
asdppp - Agile Software Development. Principles, Patterns, and Pratices  
clarch - Clean Architecture  

