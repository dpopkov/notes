ООД
===

* [1 - Что такое SOLID?](#q01)
* [1.1 - Каковы признаки плохого кода?](#q01.1)
* [2 - Для чего используется JavaDoc?](#q02)
* [3 - Как писать JavaDoc?](#q03)
* [4 - Что такое Java code conventions?](#q04)
* [5 - Расскажите про принципы составления Java класса](#q05)
* [6 - Что такое SRP?](#q06)
* [6.1 - Что такое Cohesion?](#q0601)
* [6.2 - Что такое Responsibility (Ответственность)?](#q0602)
* [7 - Расскажите о нарушениях принципа SRP.](#q07)
* [8 - Последствия нарушения SRP.](#q08)
* [8.1 - Решения SRP.](#q0801)
* [9 - Что такое OCP?](#q09)
* [10 - Расскажите о нарушениях принципа OCP](#q10)
* [11 - Последствия нарушения OCP](#q11)
* [12 - Что такое LSP?](#q12)
* [13 - Расскажите о нарушениях принципа LSP](#q13)
* [14 - Последствия нарушения LSP](#q14)
* [15 - Что такое ISP?](#q15)
* [16 - Расскажите о нарушения принципа ISP](#q16)
* [17 - Последствия нарушения ISP](#q17)
* [18 - Что такое DIP?](#q18)
* [19 - Расскажите о нарушениях принципа DIP](#q19)
* [20 - Последствия нарушения DIP](#q20)


1 - Что такое SOLID?<a name="q01"></a>
--------------------------------------
SOLID - это акроним представляющий 5 принципов дизайна классов в объектно-ориентированном проектировании.  
S - Single Responsibility Principle,  
O - Open Closed Principle,  
L - Liskov Substitution Principle,  
I - Interface Segregation Principle,  
D - Dependency Inversion Principle.  
Эти принципы были собраны и организованы Робертом Мартином в книге "Agile Software Development. Principles, Patterns, and Practices". 
Применение этих принципов делает код более расширяемым и адаптивным к возможным изменениям, более логичным и читабельным, а также пригодным к повторному использованию.

### acdpsp
SOLID - это акроним для набора практик, которые при совместном использовании делают код адаптивным к изменениям. 


1.1 - Каковы признаки плохого кода?<a name="q01.1"></a>
--------------------------------------
__Закрепощенность (Rigidity)__ - система с трудом поддается изменениям, так как самое минимальное изменение вызывает эффект снежного кома и заставляет делать изменения в других частях системы.

__Хрупкость, Неустойчивость (Fragility)__ - в результате изменений система ломается в других местах, которые не имеют прямого отношения к изменяемому компоненту.

__Неподвижность (Immobility)__ - трудно распутать систему и выделить из нее компоненты, которые могли бы повторно использоваться в других системах.

__Вязкость (Viscosity)__ - Сделать что-либо правильно намного сложнее, чем выполнить некорректные действия.

__Неоправданная сложность__ - Проект содержит инфраструктуру не приносящую непосредственной выгоды.

__Повторяемость__ - Проект содержит повторяющиеся структуры, которые можно было бы объединить под единой абстракцией.

__Неопределенность__ - Исходный код трудно читать и понимать.


2 - Для чего используется JavaDoc?<a name="q02"></a>
----------------------------------

Для описания классов, интерфейсов, полей, конструкторов, методов и пакетов с возможностью автоматического создания документации. Джавадок описывает ответственность класса. Если при описании происходит перечисление, то это может быть признаком нарушения SRP.


3 - Как писать JavaDoc?<a name="q03"></a>
-----------------------

Javadoc помещается перед документируемым элементом и заключается в символы слэш-звездочка-звездочка и закрывающая звездочка-слэш , в начале следует общее описание класса или метода, затем могут использоваться автономные дескрипторы начинающиеся с символа @ и помещаемые в начале строки, которые применяются для документации автора, версии, параметров и возвращаемого значения метода, описания выбрасываемых исключений и ссылок. Используются также встроеенные дескрипторы в фигурных скобках, например {@link reference}. 


6 - Что такое SRP?<a name="q06"></a>
------------------------------------
SRP - Single Responsibiltiy Principle.  
Each class in your system should have only one responsibility.  
Alternative definition: You should be able to describe what each class does withou saying "and".  
Better definition: Each class should have only one reason to change.  
Class follows SRP if you can't come up with more than one reason for a class to change.
Responsibility == reason to change.  

SRP violations lead to excessive coupling.

#### acdpsp

Принцип SRP рекомендует писать код, который имеет одну и только одну причину для изменений. Если у класса более одной причины меняться, это значит у него более одной ответственности. Классы с более чем одной ответственностью должны быть разбиты на меньшие классы, каждый из которых должен иметь только одну ответственность и причину для изменения.

Через процесс делегирования и абстракции класс имеющий слишком много причин для изменений должен делегировать одну или несколько ответственностей другим классам.

#### asdppp

Первоначально этот принцип соотносился с понятием Cohesion (Связность,Сплоченность) - функциональная взаимосвязь элементов модуля сфокусированных на одной главной цели. 
Позже (Боб Мартин) смысл сместился в сторону сил, которые вызывают изменения в модуле или классе.

__A class should have only one reason to change.__

Важно разделить ответственности на отдельные классы, потому что каждая ответственность является направлением для возможного изменения. Когда требования меняются, это изменение проявится через ответственности, которые несет на себе класс. Если класс имеет более одной ответственности, то у него будет более одной причины для изменения. В этом случае ответственности могут вступить в зацепление или сопряжение друг с другом и изменения в одной ответственности могут нарушить способность класса исполнять другие ответственности. Такой тип зацепления ведет к хрупкому дизайну который при модификации может ломаться в неожиданных местах.

#### clarch

SRP является следствием закона Конвея: лучшей является такая структура программной системы, которая формируется в основном под влиянием социальной структуры организации, использующей эту систему, поэтому каждый программный модуль имеет одну и только одну причину для изменения.

Исторически SRP формилировался так:
A module should have one, and only one, reason to change.  
Модуль должен иметь одну и только одну причину для изменения.

Програмные системы изменяются для удовлетворения потребностей пользователей и заинтересованных лиц, которые и являются причиной для измененний. В действительности здесь имеется в виду группа из одного или более человек, которые нуждаются в конкретном изменении. Тогда более полное определение будет таким:  
A module should be responsible to one, and only one, actor.  
Модуль должен нести ответственность перед одним и только одним актором или абстрактной ролью пользователя.  
Это может быть сформулировано также как: 
Класс должен иметь только одну ответственность, то есть изменения только одной части спецификации должны вызывать изменения в классе.

#### A

SRP - Принцип Единственной Ответственности утверждает, что каждый модуль или класс должен нести ответственность за одну конкретную часть функциональности предоставляемой программой и эта ответственность должна быть полностью инкапсулирована этим модулем или классом. 
Первоначально этот принцип соотносился с понятием Cohesion (Связность, Сплоченность) - это связность элементов модуля сфокусированных на одной главной цели.
Позже Боб Мартин сместил смысл в сторону сил, которые вызывают изменения в модуле или классе. "Класс должен иметь только одну причину для изменения".
Чем больше класс имеет ответственностей, тем больше у него причин для изменения. В этом случае ответственности могут вступать в зацепление или сопряжение (Coupling) друг с другом и изменения в одной ответственности (например изменения в требованиях) могут нарушить способность класса исполнять другие ответственности. Такой тип зацепления ведет к хрупкому дизайну который при модификации может ломаться в неожиданных местах.


6.1 - Что такое Cohesion?<a name="q0601"></a>
-------------------------

Cohesion - связность или прочность - это то, насколько хорошо все методы класса или все фрагменты метода соответствуют главной цели, - иначе говоря, насколько сфокусирован класс на той задаче, которую он решает.


6.2 - Что такое Responsibility (Ответственность)?<a name="q0602"></a>
-------------------------------

Responsibility (Ответственность) - это причина для изменения. Если можно представить более одного мотива для изменения класса, это значит класс имеет более одной ответственности.


7 - Расскажите о нарушениях принципа SRP.<a name="q07"></a>
-----------------------------------------

Если у класса более чем одна ответственность, то между этими ответственностями может произойти зацепление (Coupling) и тогда изменения в одной ответственности могут нарушить способность класса обслуживать другие ответственности.
Например класс Employee содержит три метода: calculatePay(), reportHours(), и save(). Здесь нарушается SRP, так как эти 3 метода ответственны перед бухгалтерией, отделом персонала, и администратором БД. В таком классе объединен код обслуживающий разных акторов. В результате изменения инициированные одним актором, могут затронуть и негативно повлиять на код, обслуживающий других акторов.


8 - Последствия нарушения SRP.<a name="q08"></a>
------------------------------

1-е последствие - возможность случайного дублирования.
В примере с Employee методы calculatePay() и reportHours() могут использовать общий алгоритм расчета не сверхурочных часов, который, чтобы избежать дублирования кода, был помещен в метод regularHours(). Если бухгалтерия решит изменить алгоритм расчета часов, то разработчик внесет требуемые изменения, несмотря на то, что другой актор - отдел кадров не в курсе этого изменения. Ими будет использоваться система выдающая новый результат без их ведома и это может быть обнаружено не сразу, что приведет к неприятным последствиям.  
То есть в данном случае произошло зацепление (Coupling) между двумя ответственностями класса, которое привело к хрупкости (Fragility), то есть изменения в одном месте системы привело к поломке в другом неожиданном месте.

2-е последствие - это риск при слиянии изменений. Например администратор БД вносит изменение в схему таблицы, а сотрудники отдела персонала хотят изменить формат отчета reportHours(). Два разных разработчика вносят независимо друг от друга изменения в одном классе, что потом приводит к необходимости разрешения коллизий при слиянии. Это подвергает риску оба изменения, так как при объемных изменениях провести слияние сложно и есть вероятность ошибки.


8.1 - Решения SRP.<a name="q0801"></a>
------------------

Наиболее очевидным способом решить проблему является отделение данных от функций и выделение данных в самостоятельный класс, а также создание отдельных классов для обслуживания разных ответственностей. Например PayCalculator, HourReporter, EmployeeSaver. Так как кол-во классов увеличится, то можно применить шаблон Фасад и делегировать эти ответственности соответствующим объектам.

Для реализации SRP также используется шаблон Декоратор.

9 - Что такое OCP?<a name="q09"></a>
-------------------

#### asdppp

OCP: The Open-Closed Principle - Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
То есть система должна легко подвергаться расширению путем добавления нового кода, а не изменения существующего кода.
Если одно изменение в программе приводит к каскаду изменений в зависимых местах, это признак Жесткости (Закрепощенность, Rigidity). В этом случае следует произвести рефакторинг, с тем чтобы дальнейшие изменения такого типа не приводили к большим модификациям. Если OCP применен правильно, то дальнейшее расширение достигается за счет добавления нового кода, а не изменения существующего кода.

Решением является введение абстракции способной защитить от возможных последующих изменений, когда код в классе закрытом для модификации, использует вызовы методов интерфейса или абстрактного класса, потомки которого могут добавлять и расширять функциональность.
При этом OCP не может быть применен против всех возможнох изменений, а только против наиболее вероятных, так как лишние абстракции увеличивают сложность дизайна программы.


10 - Расскажите о нарушениях принципа OCP<a name="q10"></a>
-----------------------------------------

#### asdppp

Примером нарушения OCP может быть программа отрисовки геометрических фигур, которая в цикле перебирает фигуры и в зависимости от типа фигуры вызывает ту или иную функцию отрисовки. Если будут добавлены новые типы фигур, то в этот код должны быть внесены изменения учитывающие новые типа, то есть он не является закрытым для модификации.


11 - Последствия нарушения OCP<a name="q11"></a>
------------------------------

#### asdppp

В примере с отрисовкой фигур, где цикл отрисовки в зависимости от типа фугуры вызывет ту или иную функцию отрисовки, при добавлении нового типа фигуры изменениями будет затронуто не только отрисовка фигур, но код в любом классе или методе, исполнение которого зависит от типа фигуры. Поиск всех мест, где необходимо будет внести изменения может быть затруднительным. То есть незакрытый от модификации класс делает структуру программы Жесткой (Закрепощенной), а также Хрупкой (Неустойчивой), так как можно пропустить некоторые места, где необходимо добавить обработку новых типов фигур.
Решением будет создать абстрактный метод отвечающий за отрисовку фигуры, тогда каждый класс нового типа геометрической фигуры может быть добавлен в программу и при этом, благодаря полиморфизму, не потребуется менять код вызывающий метод отрисовки. В таком случае не будет необходимости также искать места нуждающиеся в обновлении из-за добавления нового типа, следовательно такой код не будет Хрупким (Неустойчивым).


12 - Что такое LSP?<a name="q12"></a>
--------------------

#### asdppp

__Subtypes must be substitutable for their base types.__  
__Базовые типы должны заменяемы подтипами.__

При наследовании поведение подтипа не должно противоречить поведению базового типа. 


LSP - мы можем использовать взаимозаменяемые части, которые должны придерживаться некоторого договора, который позволяет заменять их друг на друга


13 - Расскажите о нарушениях принципа LSP<a name="q13"></a>
-----------------------------------------

#### asdppp

Предположим что есть метод принимающий в качестве параметра некий базовый класс A. Также существует его подтип B, который при передаче его в этот метод приводит к неправильному поведению метода. В данном случае подкласс B нарушает принцип LSP. Если программист будет в этом методе проверять, не является ли переданный аргумент объектом класса B, то это нарушит принцип OCP, так как метод не будет закрыт для модификации для всех последующих подклассов класса A. Такие проверки являются неправильной реакцией на нарушение LSP.

Пример 1.
Классы Circle и Square наследуют от базового класса Shape. В обоих под-классах есть метод draw(), но его нет в базовом классе. Тогда метод занимающийся отрисовкой массива Shape вынужден проверять тип Shape и делать приведение типа для вызова метода draw(), что является нарушением OCP. То что подклассы не могут быть подставлены на место базового класса является нарушением LSP, что далее приводит к нарушению OCP.

Пример 2.
Класс Square наследует от класса Rectanlge. Для класса Square сеттеры длины и ширины устанавливают одинаковые значения для обоих полей. Предположим что есть метод принимающий Rectangle, меняющий его длину и ширину, затем делающий вычисления основанные на значениях переданных в сеттеры. Если реальным объектом будет Square, то вычисления могут быть неверными, так как поведение Square касающееся его длины и ширины отличается от поведения Rectangle. Это является нарушением LSP.


14 - Последствия нарушения LSP<a name="q14"></a>
------------------------------


15 - Что такое ISP?<a name="q15"></a>
-------------------

#### asdppp

__Clients should not be forced to depend on methods that they do not use.__

Когда клиенты вынуждены зависеть от методов, которые они не используют, то они зависят от изменений в этих методах. Это приводит к ненамеренному зацеплению между всеми клиентами. Другими словами, когда клиент зависит от класса содержащего методы не используемые клиентом, но используемые другими клиентами, тогда это клинет будет испытывать влияние от изменений в интерфейсе, к которым вынудят эти другие клиенты. Такого зацепления следует избегать где только возможно и производить разделение интерфейсов.

ISP - следует избегать заависимостей от того, что не используется


16 - Расскажите о нарушения принципа ISP<a name="q16"></a>
---------------------------------------- 

17 - Последствия нарушения ISP<a name="q17"></a>
------------------------------


18 - Что такое DIP?<a name="q18"></a> 
------------------- 

__a. High-level modules should not depend on low-level modules. Both should depend on abstractions.__  
__b. Abstractions should not depend on details. Details should depend on abstractions.__  



19 - Расскажите о нарушениях принципа DIP<a name="q19"></a>
-----------------------------------------


20 - Последствия нарушения DIP<a name="q20"></a>
------------------------------

При нарушении DIP модули и классы верхнего уровня будут испытывать влияние от изменения в нижнем уровне. Кроме того их нельзя будет использовать повторно с другим нижним уровнем.


DIP - модули верхних уровней не должны зависет от модулей нижних уровней, оба должны зависеть от абстракций 


Legend
------

acdpsp - Agile coding with Design Patterns and SOLID Principles  
asdppp - Agile Software Development. Principles, Patterns, and Pratices  
clarch - Clean Architecture  

