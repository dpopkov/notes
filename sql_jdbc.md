SQL, JDBC
=========

* [1.0 Что такое потенциальный ключ?](#q0100)
* [1  Что такое первичный ключ?](#q01)
* [2  Что такое внешний ключ?](#q02)
* [3  Что такое нормализация БД?](#q03)
* [3.0 Что такое Нормальная Форма](#q0300)
* [3.0.1 Что такое функциональная зависимость](#q030001)
* [3.1 Первая Нормальная Форма](#q0301)
* [3.2 Вторая Нормальная Форма](#q0302)
* [3.3 Третья Нормальная Форма](#q0303)
* [3.4 Нормальная Форма Бойса-Кодда (НФБК) (частная форма 3НФ)](#q0304)
* [4  Что такое денормализация БД? Для чего она нужна?](#q04)
* [5  Что такое кластерный и некластерный индекс?](#q05)
* [6  Какие типы соединений (join) таблиц существуют? В чем их разница?](#q06)
* [7  Что такое SQL курсор?](#q07)
* [8  Опишите шаги по созданию и использованию курсора](#q08)
* [10  Что такое транзакция?](#q10)
* [10.1 Что такое ACID?](#q1001)
* [10.2 Феномены возможные при параллельном выполнении транзакций](#q1002)
* [10.3 Уровни изоляции транзакций](#q1003)
* [11  Что такое триггер? Какие типы триггеров вы знаете?](#q11)
* [12  В чем разница между WHERE and HAVING?](#q12)
* [13  Что такое подзапрос (sub-query)?](#q13)
* [14  Что такое union?](#q14)
* [15  Что такое group by?](#q15)
* [17  Что такое хранимые процедуры?](#q17)
* [18  Что такое view (представление)?](#q18)
* [19  Опишите процесс создания запроса через JDBC?](#q19)
* [20  Для чего используется конструкция try-with-resources?](#q20)



1.0 Что такое потенциальный ключ?<a name="q0100"></a>
---------------------------------
Потенциальный ключ - это комбинация атрибутов таблицы, позволяющая уникальным образом индентифицировать строки в ней. Ключ может состоять только лишь из одного атрибута таблицы, либо из двух и более атрибутов. Такой составной потенциальный ключ должен являться неизбыточным, т.е. никакое подмножество атрибутов, входящих в него, не должно обладать свойством уникальности.

При наличии в таблице более одного потенциального ключа одни из них выбирается в качестве Первичного Ключа, а остальные будут являться Альтернативными Ключами.


1  Что такое первичный ключ?<a name="q01"></a>
----------------------------

### Википедия:
__Первичный ключ__ - один из _потенциальных ключей_ отношения, выбранный в качестве основного ключа.  
__Потенциальные ключи__ - подмножество атрибутов отношения, удовлетворяющее требованиям уникальности и минимальности (несократимости).  
__Уникальность__ - не существует двух кортежей, в которых значения этого подмножества атрибутов совпадают.  
__Минимальность__ - если из потенциального ключа убрать любой атрибут, то он перестанет быть уникальным.

### Ответ:
__Первичный ключ__ - поле или набор полей (атрибутов), однозначно (уникально) идентифицирующее запись. Таблица может иметь только один первичный ключ, который должен содержать только уникальные значения и не может иметь значение NULL. Если первичный ключ состоит из двух или более полей, то он является композитным (составным). Композитный первичный ключ является несократимым. Это значит, что первичный ключ не содержит таких полей, после удаления которых ключ сохранит свойство уникальности. То есть если из составного Первичного Ключа убрать одно поле (атрибут), то он перестанет быть уникальным.  

Если есть множество потенциальных ключей, обладающих такими свойствами, то из них выбирается один основной, который будет являться Первичным Ключом и использоваться для идентификации записи. В качестве первичного ключа выбирают тот ключ, который имеет наименьший размер, а также сохраняет свою уникальность со временем. Если нет подходящего компактного естественного ключа, то в качестве первичного используется суррогатный ключ.
Первичный ключ помогает поддерживать целостность данных таблицы тем, что предотвращает дублирование записей, а также служит для установления связей между таблицами.


2  Что такое внешний ключ?<a name="q02"></a>
--------------------------

### Я:
Внешний ключ - поле ссылающееся на первичный ключ в другой таблице.

### Википедия:
__Внешний ключ__ - подмножество атрибутов отношения, значения которых должны совпадать со значениями некоторого потенциального ключа другого отношения.

### webformyself.com:
__Внешний ключ__ - ключ используемый для объединения двух таблиц, состоящий из поля или комбинации полей, значения которых соответствуют первичному ключу в другой таблице.

### Ответ:
__Внешний ключ__ - ключ используемый для объединения таблиц. Он дает возможность ссылаться на другую таблицу или на саму себя. Состоит из поля или комбинации полей, значения которых должны совпадать со значениями потенциального ключа в другой (или той же самой) таблице.

Другими словами, если мы хотим установить связь между таблицами, то берем значение потенциального ключа из первой таблицы и вставляем его во вторую таблицу, где он становится внешним ключом.

Таблица, содержащая Внешний Ключ, называется Ссылающейся таблицей (referencing table). Таблица, содержащая соответствующий Потенциальный Ключ, называется Ссылочной (Целевой) таблицей (referenced table). Внешний ключ ссылается на Потенциальный ключ в ссылочной таблице.

Внешний ключ не обязан быть уникальным.

Ограничение, согласно которому значения Внешних ключей должны соответствовать значениям Потенциальных ключей, называется Ограничением Ссылочной Целостности (Ссылочным ограничением).

Пример:  
so_id integer REFERENCES so_headers(id);  
FOREIGN KEY (so_id) REFERENCES so_headers (id);


3  Что такое нормализация БД?<a name="q03"></a>
-----------------------------

[Wikipedia: Нормальная форма](https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0)

[Habr: Нормализация отношений. Шесть нормальных форм](https://habr.com/ru/post/254773/)

https://support.microsoft.com/ru-ru/help/283878/description-of-the-database-normalization-basics

__Нормализация__ - процесс преобразования отношений к виду, отвечающему Нормальным Формам. 
Это пошаговый, обратимый процесс, в ходе которого отношения приводятся сначала к 1НФ, затем ко 2НФ и т.д.

В процессе нормализации исходная схема БД заменяется другой схемой, при которой структура БД становится более простой и логичной, с уменьшенной логической избыточностью.  

Целью нормализации является уменьшение потенциальной противоречивости хранимой информации, которая может возникать в результате ошибок обновления. 
Нормализация не имеет целью изменение производительности или физического объема.


[Habr: Нормализация отношений. Первая и вторая нормальные формы](https://habr.com/ru/post/129195/)


3.0 Что такое Нормальная Форма<a name="q0300"></a>
------------------------------
_Нормальная Форма_ - совокупность требований, предъявляемых к структуре отношения для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц), потециально приводящих к логически ошибочным результатам выборки или изменения данных.


3.0.1 Что такое функциональная зависимость<a name="q030001"></a>
------------------------------------------
Функциональая зависимость - значение атрибута однозначно определяет значение зависимого атрибута.


3.1 Первая Нормальная Форма<a name="q0301"></a>
---------------------------

__1НФ__ - Атрибуты являются простыми (атомарными), не содержат множественных значений или списков (multivalued attributes) (например два или более номера телефона, через запятую или иной разделитель), не являются составными (multipart attributes), то есть не могут быть разделены на более простые атрибуты описываемой сущности (например имя и фамилия). 

Другими словами при 1НФ пересечение каждого столбца и строки содержит одно и только одно значение.


3.2 Вторая Нормальная Форма<a name="q0302"></a>
---------------------------

2НФ относится только к случаям если в схеме есть составной Первичный Ключ.

__2НФ__ = 1НФ + наличие Первичного Ключа + любой неключевой атрибут зависит от только Первичного Ключа (ПК) и при этом в составе ПК отсутствует меньшее подмножество атрибутов, от которого также можно вывести данную функциональную зависимость.

Другими словами во 2НФ отсутствуют зависимость атрибутов от отдельных полей входящих в состав составного Первичного Ключа.


3.3 Третья Нормальная Форма<a name="q0303"></a>
---------------------------

__3НФ__ = 2НФ + каждый не ключевой атрибут не находится в транзитивной функциональной зависимости от Первичного ключа.

Другими словами не должно быть зависимостей одних не ключевых атрибутов от других. Все атрибуты зависят только от ключа.


3.4 Нормальная Форма Бойса-Кодда (НФБК) (частная форма 3НФ)<a name="q0303"></a>
-----------------------------------------------------------


4  Что такое денормализация БД? Для чего она нужна?<a name="q04"></a>
---------------------------------------------------

https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F

__Денормализация__ - намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации, применяемое к уже нормализованной БД с целью повышения производительности. После денормализации должно происходить ускорение операций чтения из базы за счет добавления избыточных данных, которые до денормализации были получены через соединение разных таблиц.  

При нормализации количество таблиц увеличивается, что при запросах требует операций соединения таблиц, которые увеличивают время выполнения запроса.  

Для повышения производительности запросов может производится композиция нескольких таблиц в одну, которая находится, как правило во 2НФ, но не в 3НФ. Новая таблица фактически является хранимым результатом операции соединения исходных таблиц. За счет этого при запросе операции не производится соединения таблиц и запрос работает быстрее.

Денормализация также может включать в себя предварительное вычисление часто запрашиваемых значений.



5  Что такое кластерный и некластерный индекс?<a name="q05"></a>
----------------------------------------------
Кластерный и некластерный индекс - это индексы отличающиеся по способу хранения данных.

Обычный индекс - это отсортированный набор столбца таблицы, по которому он построен. Индекс хранит ссылки на данные каждой строки. Однако из-за того, что данные в самой таблице неотсортированны, то переходы по ссылкам и чтение из разных частей таблицы отнимают ощутимое время.

Поэтому в отличие от обычного, кластерный индекс хранит в древовидной структуре не только значения столбца, но и данные соответствующей строки. Это позволяет минимизировать количество операций чтения с диска при работе с таким индексом. Поскольку данные являются частью структуры индекса, то в таблице может быть только один кластерный индекс, а из-за сложной логики хранения индексов и данных операции записи и изменения ключевых полей являются ресурсоемким процессом. Поэтому для кластерные индексы следует использовать редко изменяемые поля.


6  Какие типы соединений (join) таблиц существуют? В чем их разница?<a name="q06"></a>
--------------------------------------------------------------------
Типы соединений (join):

inner join - соединение таблиц, при котором записи первой таблицы соединяются с записями второй таблицы по указанному условию.  
Другими словами, результирующий набор содержит записи включающие данные строк из обоих таблиц для которых выполняется заданное условие.

outer join - соединение таблиц, при котором возвращаются не только данные из обеих таблиц соединенные по указанному условию, но также те записи, для которых условие не выполнено. В тех строках, для которых не нашлось соответсвующих строк в другой таблице, столбцы другой таблицы получают значение NULL.  

left outer join - возвращает все строки из левой таблицы, плюс присоединенные по заданному условию строки правой таблицы.
right outer join - возвращает все строки из правой таблицы, плюс присоединенные по заданному условию строки левой таблицы.
full outer join - возввращает соединенные по условию строки, а также строки из левой таблицы, для которых не нашлось соответствующих строк в правой таблице, и строки из правой таблицы, для которых не нашлось соответствующих строк в левой таблице.

cross join - перекрестное (декартово) соединение таблиц, при котором все записи первой таблицы соединяются со всеми записями второй таблицы и условие соединения не указывается.

natural join - это не тип соединения, а указание условия соединения. Natural join соединяет строки при условии совпадения значений из столбцов имеющих одинаковые имена в обеих таблицах (по умолчанию inner join). Не рекомендуется использовать из-за отсутствия явного указания имен столбцов, по которым производится соединение, что может приводить к проблемам при добавлении или переименовании столбцов.


7  Что такое SQL курсор?<a name="q07"></a>
------------------------

Вариант 1.
Команды манипулирования данными SELECT, UPDATE, DELETE работают сразу с группами строк. Эти группы, вплоть до отдельных строк, можно выбрать с помощью опции WHERE. А если надо перебрать строки некоторой таблицы последовательно, одну за другой? На этот случай в языке SQL существуют курсоры. Курсор (current set of record) - временный набор строк, который можно перебирать последовательно, с первой до последней. Это эффективный способ получать большие наборы строк из функций по частям. Если выборка осуществляется через курсорые переменные, которые всегда имеют специальный тип данных refcursor.

Вариант 2.
Курсор - это специальный объект, инкапсулирующий запрос SELECT и позволяющий читать результаты по несколько строк за раз.   [Изучаем PostgreSQL 10 - 2019, p212]

Вариант 3.
Курсор - это структура, которая позволяет делать последовательный проход на записям БД и дает возможность последовательно выполнять операции во время этого прохода, такие как чтение, добавление или удаление записей. Для БД курсор является аналогом Итератора.

Курсоры используются для обработки отдельных строк полученных при запросах. Курсор позволяет манипулировать результирующим набором и производить действия над строками результирующего набора.

В SQL процедурах курсор позволяет определить результирующий набор строк и выполнять сложную логику над строками набора последовательно (строка за строкой). SQL процедура может возвращать курсор.

Курсор можно рассматривать как указатель на строку в результирующем наборе строк. Курсор указывает только на одну строку, но может перемещаться со строки на строку.

### A

Курсор БД это управляющая структура которая позволяет последовательно получить доступ к записям таблицы. Для БД курсор является аналогом итератора, то есть он указывает на отдельную строку в результирующем наборе строк, полученном в результате запроса. SQL курсоры могут выбирать несколько строк за одну операцию, а также двигаться в обратном порядке. Синтаксис для работы с курсором в SQL и процедурном языке (PL/pgSQL) имеет различия.
Курсор может быть входным параметром функции и функция может также возвращать ссылку на курсор, что является способом получать большие наборы строк по частям.

[Wikipedia: Cursor](https://en.wikipedia.org/wiki/Cursor_%28databases%29)  
[Wikipedia: SQL_problems](https://en.wikipedia.org/wiki/SQL_problems_requiring_cursors)



8  Опишите шаги по созданию и использованию курсора<a name="q08"></a>
---------------------------------------------------

Последовательность по созданию и использованию курсора:

* Объявление курсора. Оператор DECLARE позволяет создавать курсоры, с помощью которых можно выбирать по очереди некоторое кол-во строк из результата большого запроса.
    ```
    DECLARE cursor-name CURSOR FOR query;
    DECLARE cursor-name SCROLL CURSOR FOR query;    -- объявление прокручиваемого курсора
    ```

* Открытие курсора (только в PL/pgSQL)- необходимо для получения данных, при этом курсор позиционируется перед первой записью результирующего набора.
    ```
    OPEN cursor-name;
    ```

* Чтение из курсора - получает результат запроса через курсор и по умолчанию (если не задано другое) перемещается на следующую запись.
    ```
    FETCH number FROM cursor-name;      -- SQL, выбрать следующие number строк
    FETCH PRIOR FROM cursor-name;       -- SQL, выбор предыдушей строки
    FETCH cursor-name INTO variables;   -- PL/pgSQL
    ```

* Закрытие курсора для освобождения ресурсов, связанных с открытым курсором. Курсоры закрываются автоматически при завершении транзакции либо командной CLOSE, когда он становится ненужным. После закрытия никакие операции с ним невозможны.
    ```
    CLOSE cursor-name;
    ```

* Удаление курсора из памяти (DEALLOCATE ?)


10  Что такое транзакция?<a name="q10"></a>
-------------------------

[Вариант 1 - Википедия.](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))
Группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность даннымх и назависимо от параллельно идущих других транзакций, либо не выполнена вообще, и тогда она не должна произвести никакого эффекта.

Вариант 2.

Транзакция - это совокупность операций над базой данных, которые вместе образуют логически целостную процедуру, и могут быть либо выполнены все вместе, либо не будут выполнена ни одна из них.

Транзакцию начинают командой START TRANSACTION или BEGIN, за которой следуют отдельные команды, в промежутках между которыми БД может существовать в несогласованном состоянии.
Далее у транзакции может быть два исхода: либо все изменение данных проходят успешно и зафиксируются в базе данных командой завершения транзакции - COMMIT, либо (если произошел какой-то сбой) транзакция отменяется, и отменяются все изменения, выполненные в ходе транзакции, то есть производится откат командой ROLLBACK.

Таким образом трансакции помогают обеспечить согласованность базы данных (непротиворечивость хранимой информации) переводя базу данных из одного согласованного состояния в другое согласованное состояние.

Вариант 3.

Транзакция - это группа последовательных операций с Базой Данных, рассматриваемых вместе как одна единая и неделимая единица работы. Транзация может быть выполнена либо целиком и успешно, с соблюдением целостности данных и независимо о других параллельно идущих транзакций, либо не выполнена совсем, если произошел какой-то сбой в процессе выполнения транзакции. Транзакция является средством обеспечения согласованности данных.

Например если нужно выполнить несколько команд добавляющих или обновляющих данные, а в промежутках между выполнением этих отдельных команд БД существовала бы в состоянии некорректных, несогласованных данных, то перед началом выполнения этих команд сначала начинают транзакцию (BEGIN), затем выполняют последовательность команд, а затем завершают транзакцию (COMMIT).


10.1 Что такое ACID?<a name="q1001"></a>
--------------------

Акроним ACID описывает требования к транзакционной системе, которой является СУБД, обеспечивающие наиболее надежную и предсказуемую ее работу.
Эти требования влючают:

1) _Атомарность_ (Atomicity). Транзакция либо выполняется целиком, либо не выполняется совсем. То есть либо фиксируются результаты всех операций транзакции, либо не фиксируется ни одна операция транзакции. Если бы в одной из операций произошла ошибка или мы сами прервали транзацию командой ROLLBACK, то база данных осталась бы в таком же состоянии, в котором была до команды BEGIN.

2) _Согласованность_ (Consistency). Когда фиксируются изменения транзакции, все ограничения целостности должны быть выполнены, иначе транзакция прерывается. Таким образом, в начале транзакции данные находятся в согласованном состоянии, и в конце работы транзакция оставляет их согласованными.

3) _Изоляция_ (Isolation). Пока трансакция не зафиксирована, другие пользователи не увидят несогласованные данные. За счет этого СУБД способна параллельно обслуживать много сеансов. Несколько сеансов могут одновременно читать и изменять данные, не блокируя друг друга. Блокировка возникает только при одновремнном изменении одной и той же строки двумя разными процессами.

4) _Долговечность_ (Durability). После успешной фиксации транзакции данные надежно сохранены в БД и впоследствии могут быть извлечены из нее, независимо от последующих возможных сбоев.


10.2 Феномены возможные при параллельном выполнении транзакций<a name="1002"></a>
--------------------------------------------------------------

При параллельном выполнении транзакций возможны следующие феномены:

1) Потерянные обновления (lost update). Когда разные транзакции одновременно изменяют одни и те же данные, то после фиксации изменений может оказаться, что одна транзакция перезаписала данные, обновленные и зафиксированные другой транзакцией.

2) "Грязное" чтение (dirty read). Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась. Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе.

3) Неповторяющееся чтение (non-repeatable read). При повторном чтении тех же самых данных в рамках одной транзакции оказывается, что другая транзакция успела изменить и зафиксировать эти данные. В результате тот же самый запрос выдает другой результат.

4) Фантомное чтение (phantom read). Транзакция повторно выбирает множество строк в соответствии с одним и тем же критерием. В интервале времени между выполнением этих выборок другая транзакция добавляет новые строки и успешно фиксирует изменения. В результате при выполнении повторной выборки в первой транзакции может быть получено другое множество строк.

5) Аномалия сериализации (serialization anomaly). Результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом не одного из возможных вариантов упорядочения этих транзакций, если бы они выполнялись последовательно.


10.3 Уровни изоляции транзакций<a name="q1003"></a>
-------------------------------

В стандарте SQL предусмотрено четыре уровня изоляции транзакций. Каждый более высокий уровень включает в себя все возможности предыдущего.

1) Read Uncommitted. Это самый низкий уровень изоляции. На этом уровне допускается чтение "грязных" (незафиксированных) данных. 
В PostgreSQL чтение "грязных" данных на этом уровне не допускается.

2) Read Committed. Не допускается чтение "грязных" (незафиксированных) данных. Транзакция может видеть только те незафиксированные изменения данных, которые произведены в ходе выполнения ею самой. 
В PostgreSQL этот и предыдующий уровень совпадают.

3) Repeatable Read. Не допускается чтение "грязных" (незафиксированных) данных и неповторяющееся чтение.
В PostgreSQL на этом уровне также не допускается фантомное чтение.

4) Serializable. Не допускается ни один из феноменов, в том числе аномалии сериализации.


11  Что такое триггер? Какие типы триггеров вы знаете?<a name="q11"></a>
------------------------------------------------------

### Learning PostgreSQL

Триггеры позволяют разработчику обрабатывать события, генерируемые командами INSERT, UPDATE, DELETE и другии. Триггеры используются для моделирования сложных бизнес-требований, которые трудно реализовывать средствами одного лишь SQL.

### Practical SQL

Триггер является указанием БД на вызов функции когда происходит определенное событие, относящееся к таблице или представлению (view), такое как INSERT, UPDATE, DELETE, TRUNCATE. Когда заданное событие происходит, то триггер вызывает функцию или процедуру, которая выполняет нужные действия. Можно установить триггер на срабатывание Перед, После или Вместо события, а также можно установить триггер на срабатывание для каждой строки затрагиваемой событием, либо один раз для целой операции. Например при удалении 20 строк из таблицы можно установить триггер для срабатывания один раз или при удалении каждой строки.

```sql
CREATE TRIGGER name { BEFORE | AFTER | INSTEAD OF } event
ON table-name
FOR [ EACH ] { ROW | STATEMENT }
EXECUTE PROCEDURE function-name ( arguments )
```


12  В чем разница между WHERE and HAVING?<a name="q12"></a>
-----------------------------------------
Отличия WHERE от HAVING состоит в том, что условия WHERE применяются до группировки (в них можно использовать столбцы исходных таблиц), а условия HAVING - после группировки (и в них можно также использовать столбцы таблицы-результата).


13  Что такое подзапрос (sub-query)?<a name="q13"></a>
------------------------------------
Вариант 1:

Оператор SELECT формирует таблицу, которая может быть выведена в качестве результата, а может быть использована в другой конструкции языка SQL в любом месте, где по смыслу может находиться таблица. Такая вложенная команда SELECT, заключенная в круглые скобки называется подзапросом.

Вариант 2:

Подзапрос - это вложенная команда SELECT, заключенная в круглые скобки и являющийся частью более общего запроса. 
Подзапрос может присутствовать в месте, где по смыслу может находиться таблица. 

Подзапрос может быть скалярным, то есть возвращать одну строку и один столбец, с которым можно сравнивать другие значения.  
Подзапрос также может возвращать множество скалярных значений, которые могут использоваться в предикате IN. 
Если подзапрос не зависит от значений, возвращаемым основным внешним запросом, то он называется некоррелированным и выполняется только один раз для всего внешнего запроса.
Если подзапрос содержит ссылку на таблицу из внешнего запроса, то это коррелированный (связанный) запрос, и он может выполнятся для каждой строки, обрабатываемой во внешнем запросе.

Practical SQL:

Подзапрос вложен в другой запрос. Обычно он используется для вычисления значение или получения набора данных передаваемого в основной запрос. Подзапрос заключается в скобки и используется там где он необходим. Например подзарпос может возвращать набор строк, который будет интерпретироваться как таблица в части FROM основного запроса. Или подзапрос может возвращать скалярное значение, которое будет частью выражения фильтрующего выборку с помощью условия WHERE или HAVING. Либо возвращать список, который будет использоваться оператором IN.

```sql
SELECT first_name, last_name 
FROM employees
WHERE employee_id IN (
	SELECT id 
	FROM retirees);
```

14  Что такое union?<a name="q14"></a>
--------------------


15  Что такое group by?<a name="q15"></a>
-----------------------


17  Что такое хранимые процедуры?<a name="q17"></a>
---------------------------------

Хранимые процедуры - это набор инструкций, который компилируется один раз и хранится на сервере БД. Хранимая процедура может быть написана на процедурном языке специфичном для конкретной СУБД. Например Oracle использует PL/SQL, PostgreSQL - PL/pgSQL. Также хранимые процедуры могут быть написаны на более высокоуровневых языках, например на Java или Python.
Поскольку хранимые процедуры компилируются один раз и хранятся на сервере, то они выполняются быстрее, чем стандартные SQL запросы.  
Вызов хранимой процедуры в зависимости от конкретной СУБД производится с помощью команды CALL или EXECUTE, либо в составе команды SELECT.
Хранимую процедуру также можно вызывать из Java с помощью CallableStatement.

[Википедия](https://ru.wikipedia.org/wiki/%D0%A5%D1%80%D0%B0%D0%BD%D0%B8%D0%BC%D0%B0%D1%8F_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%B0)  
[Хранимые процедуры для Java-программистов](http://javatutor.net/articles/stored-procedures-for-java-programmers)


18  Что такое view (представление)?<a name="q18"></a>
-----------------------------------

db illum p 132 (4.6 Views)

### SqlQueries4MM

Представление это виртуальная таблица составленная из одной или более таблиц базы данных. Представление не содержит данные, а отображает данные хранящиеся в других таблицах. В базе данных хранится только структура Представления, которое по сути является Запросом, сохраненным под определенным именем.

### PostgreSQL. Основы языка SQL.

При работе с БД зачастую приходится многократно выполнять одни и те же запросы, которые могут быть весьма сложными и требовать обращения к нескольким таблицам. Чтобы избежать необходимости многократного формирования таких запросов, можно использовать представления (views).
`CREATE VIEW имя-представления AS запрос;`  
К представлению можно обращаться без создания сложного запроса как к обычной таблице.
Представления не содержат данных и при каждом обращении к представлению данные выбираются из таблиц, на основе которых это представление создано.
Представления позволяют облегчить развитие и модификацию БД, потому что они могут позволить сохранить интерфейс неизменным, но сам запрос, который лежит в основе конкретного представления может измениться. При этом для прикладного программиста представление останется неизменным, поэтому не потребуется переделывать запросы к этому представлению в прикладной программе.

### Learning PostgreSQL 10

Представление действует как интерфейс или как уровень абстракции.
```sql
CREATE VIEW name AS query;
```
Представление можно считать именованным запросом или оберткой вокруг команды SELECT. Представления используются для упрощения сложных запросов, уменьшения объема SQL кода, а также для реализации уровня абстракции между языками высокого уровня и реляционными базами.

Представление это виртуальная таблица, которую вы создаете динамически, используя сохраненный запрос.

### Ответ

Представление это виртуальная таблица, динамически составляемая из одной или более таблиц БД, с использованием заранее составленного запроса. По сути представление является именованным запросом или оберткой вокруг команды SELECT. Представление не содержит данных, а отображает данные собранные из таблиц, на основе которых это представление создано. Исключение - materialized view (Postgres, Oracle), который кэширует данные собранные представлением и которое нужно периодически обновлять.
Представления дают возможность:
* Избегания дублирования одних и тех же запросов и уменьшения объема SQL кода
* Упрощения сложных запросов и отображения только необходимых столбцов нужных для конкретной задачи
* Реализации уровня абстракции между языками высокого уровня и БД
* Ограничения доступа к некоторым частям таблицы

```sql
CREATE VIEW name AS query;
```

19  Опишите процесс создания запроса через JDBC?<a name="q19"></a>
------------------------------------------------

```java
try (Connection conn = DriverManager.getConnection("url", "user", "password")) {
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM table-name");
    while (rs.next()) {
        int number = rs.getInt("intColumn");
        String value = rs.getString("stringColumn");
    }
}
```

20  Для чего используется конструкция try-with-resources?<a name="q20"></a>
---------------------------------------------------------

Конструкция try-with-resources добавлена в Java 7. Между try и блоком кода вставляются скобки, в которых объявляются и инициализируются JDBC ресурсы, один или более. Эти ресурсы закрываются автоматически, когда завершается исполнение try блока. Ресурсы должны имплементировать интерфейс java.lang.Autoclosable. Метод этого интерфейса close() автоматически вызывается при завершении блока try, что избавляет от необходимости закрывать ресурс в блоке finally.

Блок try-with-resources может также иметь обычные блоки catch и finally, которые будут исполняться после закрытия ресурса.

