SQL, JDBC
=========


1.0 Что такое потенциальный ключ?
---------------------------------
Потенциальный ключ - это комбинация атрибутов таблицы, позволяющая уникальным образом индентифицировать строки в ней. Ключ может состоять только лишь из одного атрибута таблицы, либо из двух и более атрибутов. Такой составной потенциальный ключ должен являться неизбыточным, т.е. никакое подмножество атрибутов, входящих в него, не должно обладать свойством уникальности.

При наличии в таблице более одного потенциального ключа одни из них выбирается в качестве Первичного Ключа, а остальные будут являться Альтернативными Ключами.


1  Что такое первичный ключ?
----------------------------

### Википедия:
__Первичный ключ__ - один из _потенциальных ключей_ отношения, выбранный в качестве основного ключа.  
__Потенциальные ключи__ - подмножество атрибутов отношения, удовлетворяющее требованиям уникальности и минимальности (несократимости).  
__Уникальность__ - не существует двух кортежей, в которых значения этого подмножества атрибутов совпадают.  
__Минимальность__ - если из потенциального ключа убрать любой атрибут, то он перестанет быть уникальным.

### Ответ:
__Первичный ключ__ - поле или набор полей (атрибутов), однозначно (уникально) идентифицирующее запись. Таблица может иметь только один первичный ключ, который должен содержать только уникальные значения и не может иметь значение NULL. Если первичный ключ состоит из двух или более полей, то он является композитным (составным). Композитный первичный ключ является несократимым. Это значит, что первичный ключ не содержит таких полей, после удаления которых ключ сохранит свойство уникальности. То есть если из составного Первичного Ключа убрать одно поле (атрибут), то он перестанет быть уникальным.  

Если есть множество потенциальных ключей, обладающих такими свойствами, то из них выбирается один основной, который будет являться Первичным Ключом и использоваться для идентификации записи. В качестве первичного ключа выбирают тот ключ, который имеет наименьший размер, а также сохраняет свою уникальность со временем. Если нет подходящего компактного естественного ключа, то в качестве первичного используется суррогатный ключ.

Первичный ключ помогает поддерживать целостность данных таблицы тем, что предотвращает дублирование записей, а также служит для установления связей между таблицами.


2  Что такое внешний ключ?
--------------------------

### Я:
Внешний ключ - поле ссылающееся на первичный ключ в другой таблице.

### Википедия:
__Внешний ключ__ - подмножество атрибутов отношения, значения которых должны совпадать со значениями некоторого потенциального ключа другого отношения.

### webformyself.com:
__Внешний ключ__ - ключ используемый для объединения двух таблиц, состоящий из поля или комбинации полей, значения которых соответствуют первичному ключу в другой таблице.

### Ответ:
__Внешний ключ__ - ключ используемый для объединения таблиц. Он дает возможность ссылаться на другую таблицу или на саму себя. Состоит из поля или комбинации полей, значения которых должны совпадать со значениями потенциального ключа в другой (или той же самой) таблице.

Другими словами, если мы хотим установить связь между таблицами, то берем значение потенциального ключа из первой таблицы и вставляем его во вторую таблицу, где он становится внешним ключом.

Таблица, содержащая Внешний Ключ, называется Ссылающейся таблицей (referencing table). Таблица, содержащая соответствующий Потенциальный Ключ, называется Ссылочной (Целевой) таблицей (referenced table). Внешний ключ ссылается на Потенциальный ключ в ссылочной таблице.

Внешний ключ не обязан быть уникальным.

Ограничение, согласно которому значения Внешних ключей должны соответствовать значениям Потенциальных ключей, называется Ограничением Ссылочной Целостности (Ссылочным ограничением).

Пример:  
so_id integer REFERENCES so_headers(id);  
FOREIGN KEY (so_id) REFERENCES so_headers (id);


3  Что такое нормализация БД?
-----------------------------

[Wikipedia: Нормальная форма](https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0)

[Habr: Нормализация отношений. Шесть нормальных форм](https://habr.com/ru/post/254773/)

https://support.microsoft.com/ru-ru/help/283878/description-of-the-database-normalization-basics

__Нормализация__ - процесс преобразования отношений к виду, отвечающему Нормальным Формам. 
Это пошаговый, обратимый процесс, в ходе которого отношения приводятся сначала к 1НФ, затем ко 2НФ и т.д.

В процессе нормализации исходная схема БД заменяется другой схемой, при которой структура БД становится более простой и логичной, с уменьшенной логической избыточностью.  

Целью нормализации является уменьшение потенциальной противоречивости хранимой информации, которая может возникать в результате ошибок обновления. 
Нормализация не имеет целью изменение производительности или физического объема.


[Habr: Нормализация отношений. Первая и вторая нормальные формы](https://habr.com/ru/post/129195/)


3.0 Что такое Нормальная Форма
------------------------------
_Нормальная Форма_ - совокупность требований, предъявляемых к структуре отношения для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц), потециально приводящих к логически ошибочным результатам выборки или изменения данных.


3.1 Первая Нормальная Форма
---------------------------

__1НФ__ - Атрибуты являются простыми (атомарными), не содержат множественных значений или списков (multivalued attributes) (например два или более номера телефона, через запятую или иной разделитель), не являются составными (multipart attributes), то есть не могут быть разделены на более простые атрибуты описываемой сущности (например имя и фамилия). 

Другими словами при 1НФ пересечение каждого столбца и строки содержит одно и только одно значение.


3.2 Вторая Нормальная Форма
---------------------------

2НФ относится только к случаям если в схеме есть составной Первичный Ключ.

__2НФ__ = 1НФ + наличие Первичного Ключа + любой неключевой атрибут зависит от только Первичного Ключа (ПК) и при этом в составе ПК отсутствует меньшее подмножество атрибутов, от которого также можно вывести данную функциональную зависимость.

Другими словами во 2НФ отсутствуют зависимость атрибутов от отдельных полей входящих в состав составного Первичного Ключа.


3.3 Третья Нормальная Форма
---------------------------

__3НФ__ = 2НФ + каждый не ключевой атрибут не находится в транзитивной функциональной зависимости от Первичного ключа.

Другими словами не должно быть зависимостей одних не ключевых атрибутов от других. Все атрибуты зависят только от ключа.


3.4 Нормальная Форма Бойса-Кодда (НФБК) (частная форма 3НФ)
-----------------------------------------------------------


4  Что такое денормализация БД? Для чего она нужна?
---------------------------------------------------

https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F

__Денормализация__ - намеренное приведение структуры базы данных в состояние, не соответствующее критериям нормализации, применяемое к уже нормализованной БД с целью повышения производительности. После денормализации должно происходить ускорение операций чтения из базы за счет добавления избыточных данных, которые до денормализации были получены через соединение разных таблиц.  

При нормализации количество таблиц увеличивается, что при запросах требует операций соединения таблиц, которые увеличивают время выполнения запроса.  

Для повышения производительности запросов может производится композиция нескольких таблиц в одну, которая находится, как правило во 2НФ, но не в 3НФ. Новая таблица фактически является хранимым результатом операции соединения исходных таблиц. За счет этого при запросе операции не производится соединения таблиц и запрос работает быстрее.

Денормализация также может включать в себя предварительное вычисление часто запрашиваемых значений.



5  Что такое кластерный и некластерный индекс?
----------------------------------------------
Кластерный и некластерный индекс - это индексы отличающиеся по способу хранения данных.

Обычный индекс - это отсортированный набор столбца таблицы, по которому он построен. Индекс хранит ссылки на данные каждой строки. Однако из-за того, что данные в самой таблице неотсортированны, то переходы по ссылкам и чтение из разных частей таблицы отнимают ощутимое время.

Поэтому в отличие от обычного, кластерный индекс хранит в древовидной структуре не только значения столбца, но и данные соответствующей строки. Это позволяет минимизировать количество операций чтения с диска при работе с таким индексом. Поскольку данные являются частью структуры индекса, то в таблице может быть только один кластерный индекс, а из-за сложной логики хранения индексов и данных операции записи и изменения ключевых полей являются ресурсоемким процессом. Поэтому для кластерные индексы следует использовать редко изменяемые поля.


6  Какие типы соединений (join) таблиц существуют? В чем их разница?
--------------------------------------------------------------------
Типы соединений (join):

inner join - соединение таблиц, при котором записи первой таблицы соединяются с записями второй таблицы по указанному условию.  
Другими словами, результирующий набор содержит записи включающие данные строк из обоих таблиц для которых выполняется заданное условие.

outer join - соединение таблиц, при котором возвращаются не только данные из обеих таблиц соединенные по указанному условию, но также те записи, для которых условие не выполнено. В тех строках из таблицы, для которых не нашлось соответсвующих строк в другой таблице, столбцы получают значение NULL. 

left outer join - возвращает все строки из левой таблицы, плюс присоединенные по заданному условию строки правой таблицы.
right outer join - возвращает все строки из правой таблицы, плюс присоединенные по заданному условию строки левой таблицы.
full outer join - возввращает соединенные по условию строки, а также строки из левой таблицы, для которых не нашлось соответствующих строк в правой таблице, и строки из правой таблицы, для которых не нашлось соответствующих строк в левой таблице.

natural join - соединяет строки при условии совпадения значений из столбцов имеющих одинаковые имена в обеих таблицах (по умолчанию inner join). Не рекомендуется использовать из-за отсутствия явного указания имен столбцов, по которым производится соединение, что может приводить к проблемам при добавлении или переименовании столбцов.

cross join - перекрестное (декартово) соединение таблиц, при котором все записи первой таблицы соединяются со всеми записями второй таблицы и условие соединения не указывается.



7  Что такое SQL курсор?
------------------------

Вариант 1.
Команды манипулирования данными SELECT, UPDATE, DELETE работают сразу с группами строк. Эти группы, вплоть до отдельных строк, можно выбрать с помощью опции WHERE. А если надо перебрать строки некоторой таблицы последовательно, одну за другой? На этот случай в языке SQL существуют курсоры. Курсор (current set of record) - временный набор строк, который можно перебирать последовательно, с первой до последней. Это эффективный способ получать большие наборы строк из функций по частям. Если выборка осуществляется через курсорые переменные, которые всегда имеют специальный тип данных refcursor.

Вариант 2.
Курсор - это специальный объект, инкапсулирующий запрос SELECT и позволяющий читать результаты по несколько строк за раз.   [Изучаем PostgreSQL 10 - 2019, p212]

Вариант 3.
Курсор - это структура, которая позволяет делать последовательный проход на записям БД и дает возможность последовательно выполнять операции во время этого прохода, такие как чтение, добавление или удаление записей. Для БД курсор является аналогом Итератора.

Курсоры используются для обработки отдельных строк полученных при запросах. Курсор позволяет манипулировать результирующим набором и производить действия над строками результирующего набора.

В SQL процедурах курсор позволяет определить результирующий набор строк и выполнять сложную логику над строками набора последовательно (строка за строкой). SQL процедура может возвращать курсор.

Курсор можно рассматривать как указатель на строку в результирующем наборе строк. Курсор указывает только на одну строку, но может перемещаться со строки на строку.

[https://en.wikipedia.org/wiki/Cursor_%28databases%29]
[https://en.wikipedia.org/wiki/SQL_problems_requiring_cursors]



8  Опишите шаги по созданию и использованию курсора
---------------------------------------------------


10  Что такое транзакция?
-------------------------

[Вариант 1 - Википедия.](https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))
Группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность даннымх и назависимо от параллельно идущих других транзакций, либо не выполнена вообще, и тогда она не должна произвести никакого эффекта.

Вариант 2.

Транзакция - это совокупность операций над базой данных, которые вместе образуют логически целостную процедуру, и могут быть либо выполнены все вместе, либо не будут выполнена ни одна из них. В простейшем случае транзакция состоит из одной операции.

Трансакции помогают обеспечить согласованность базы данных (непротиворечивость хранимой информации). Транзакция переводит базу данных из одного согласованного состояния в другое согласованное состояние.

У трансакции может быть только два исхода: либо все изменение данных, произведенные в ходе ее выполнения, успешно зафиксированы в базе данных, либо (если произошел какой-то сбой) транзакция отменяется, и отменяются все изменения, выполненные в ходе транзакции, то есть производится откат (ROLLBACK).

Вариант 3.

Транзакция - это группа последовательных операций с Базой Данных, рассматриваемых вместе как одна единая и неделимая единица работы. Транзация может быть выполнена либо целиком и успешно, с соблюдением целостности данных и независимо о других параллельно идущих транзакций, либо не выполнена совсем, если произошел какой-то сбой в процессе выполнения транзакции. Транзакция является средством обеспечения согласованности данных.

Например если нужно выполнить несколько команд добавляющих или обновляющих данные, а в промежутках между выполнением этих отдельных команд БД существовала бы в состоянии некорректных, несогласованных данных, то перед началом выполнения этих команд сначала начинают транзакцию (BEGIN), затем выполняют последовательность команд, а затем завершают транзакцию (COMMIT).


10.1 Что такое ACID?
--------------------

СУБД гарантирует выполнениние нескольких важных свойств. Акроним ACID описывает требования к транзакционной системе, которой является СУБД, обеспечивающие наиболее надежную и предсказуемую ее работу.

1) _Атомарность_ (Atomicity). Транзакция либо выполняется целиком, либо не выполняется совсем. То есть либо фиксируются результаты всех операций транзакции, либо не фиксируется ни одна операция транзакции. Если бы в одной из операций произошла ошибка или мы сами прервали транзацию командой ROLLBACK, то база данных осталась бы в таком же состоянии, в котором была до команды BEGIN.

2) _Согласованность_ (Consistency). Когда фиксируются изменения транзакции, все ограничения целостности должны быть выполнены, иначе транзакция прерывается. Таким образом, в начале транзакции данные находятся в согласованном состоянии, и в конце работы транзакция оставляет их согласованными.

3) _Изоляция_ (Isolation). Пока трансакция не зафиксирована, другие пользователи не увидят несогласованные данные. За счет этого СУБД способна параллельно обслуживать много сеансов. Несколько сеансов могут одновременно читать и изменять данные, не блокируя друг друга. Блокировка возникает только при одновремнном изменении одной и той же строки двумя разными процессами.

4) _Долговечность_ (Durability). После успешной фиксации транзакции данные надежно сохранены в БД и впоследствии могут быть извлечены из нее, независимо от последующих возможных сбоев.


10.2 Феномены возможные при параллельном выполнении транзакций
--------------------------------------------------------------

При параллельном выполнении транзакций возможны следующие феномены:

1) Потерянные обновления (lost update). Когда разные транзакции одновременно изменяют одни и те же данные, то после фиксации изменений может оказаться, что одна транзакция перезаписала данные, обновленные и зафиксированные другой транзакцией.

2) "Грязное" чтение (dirty read). Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась. Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе.

3) Неповторяющееся чтение (non-repeatable read). При повторном чтении тех же самых данных в рамках одной транзакции оказывается, что другая транзакция успела изменить и зафиксировать эти данные. В результате тот же самый запрос выдает другой результат.

4) Фантомное чтение (phantom read). Транзакция повторно выбирает множество строк в соответствии с одним и тем же критерием. В интервале времени между выполнением этих выборок другая транзакция добавляет новые строки и успешно фиксирует изменения. В результате при выполнении повторной выборки в первой транзакции может быть получено другое множество строк.

5) Аномалия сериализации (serialization anomaly). Результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом не одного из возможных вариантов упорядочения этих транзакций, если бы они выполнялись последовательно.


10.3 Уровни изоляции транзакций
-------------------------------


11  Что такое триггер? Какие типы триггеров вы знаете?
------------------------------------------------------


12  В чем разница между WHERE and HAVING?
-----------------------------------------
Отличия WHERE от HAVING состоит в том, что условия WHERE применяются до группировки (в них можно использовать столбцы исходных таблиц), а условия HAVING - после группировки (и в них можно также использовать столбцы таблицы-результата).


13  Что такое подзапрос (sub-query)?
------------------------------------
Вариант 1:

Оператор SELECT формирует таблицу, которая может быть выведена в качестве результата, а может быть использована в другой конструкции языка SQL в любом месте, где по смыслу может находиться таблица. Такая вложенная команда SELECT, заключенная в круглые скобки называется подзапросом.

Вариант 2:

Подзапрос - это вложенная команда SELECT, заключенная в круглые скобки и являющийся частью более общего запроса. 
Подзапрос может присутствовать в месте, где по смыслу может находиться таблица. 

Подзапрос может быть скалярным, то есть возвращать одну строку и один столбец, с которым можно сравнивать другие значения.  
Подзапрос также может возвращать множество скалярных значений, которые могут использоваться в предикате IN. 
Если подзапрос не зависит от значений, возвращаемым основным внешним запросом, то он называется некоррелированным и выполняется только один раз для всего внешнего запроса.
Если подзапрос содержит ссылку на таблицу из внешнего запроса, то это коррелированный (связанный) запрос, и он может выполнятся для каждой строки, обрабатываемой во внешнем запросе.



Они используются в предложениях SELECT, FROM, WHERE, HAVING, WITH.


14  Что такое union?
--------------------


15  Что такое group by?
-----------------------


17  Что такое хранимые процедуры?
---------------------------------


18  Что такое view (представление)?
-----------------------------------

db illum p 132 (4.6 Views)

### SqlQueries4MM

Представление это виртуальная таблица составленная из одной или более таблиц базы данных. Представление не содержит данные, а отображает данные хранящиеся в других таблицах. В базе данных хранится только структура Представления, которое по сути является Запросом, сохраненным под определенным именем.

### PostgreSQL. Основы языка SQL.

При работе с БД зачастую приходится многократно выполнять одни и те же запросы, которые могут быть весьма сложными и требовать обращения к нескольким таблицам. Чтобы избежать необходимости многократного формирования таких запросов, можно использовать представления (views).
`CREATE VIEW имя-представления AS запрос;`  
К представлению можно обращаться без создания сложного запроса как к обычной таблице.
Представления не содержат данных и при каждом обращении к представлению данные выбираются из таблиц, на основе которых это представление создано.
Представления позволяют облегчить развитие и модификацию БД, потому что они могут позволить сохранить интерфейс неизменным, но сам запрос, который лежит в основе конкретного представления может измениться. При этом дял прикладного программиста представление останется неизменным, поэтому не потребуется переделывать запросы к этому представлению в прикладной программе.



19  Опишите процесс создания запроса через JDBC?
------------------------------------------------


20  Для чего используется конструкция try-with-resources?
---------------------------------------------------------
